package wallet

import (
	"fmt"
	"strconv"
	"strings"
	"sync"

	"gitlab.com/NebulousLabs/Sia/modules"
	"gitlab.com/NebulousLabs/Sia/types"
)

// A SeedAddressInfo contains the unlock conditions and key index for an
// address derived from a seed.
type SeedAddressInfo struct {
	UnlockConditions types.UnlockConditions `json:"unlockConditions"`
	KeyIndex         uint64                 `json:"keyIndex"`
}

// MarshalJSON implements json.Marshaler.
func (info SeedAddressInfo) MarshalJSON() ([]byte, error) {
	uc := info.UnlockConditions
	pks := make([]string, len(uc.PublicKeys))
	for i := range pks {
		pks[i] = strconv.Quote(uc.PublicKeys[i].String())
	}
	timeLock := ""
	if uc.Timelock != 0 {
		timeLock = fmt.Sprintf(`"timelock":%v,`, uc.Timelock)
	}
	return []byte(fmt.Sprintf(`{"unlockConditions":{%s"publicKeys":[%s],"signaturesRequired":%v},"keyIndex":%v}`,
		timeLock, strings.Join(pks, ","), uc.SignaturesRequired, info.KeyIndex)), nil
}

// A SeedWallet is a seed-based wallet that can track spendable outputs and sign
// transactions. It is safe for concurrent use.
//
// SeedWallets can only handle siacoins, not siafunds.
type SeedWallet struct {
	sm    *SeedManager
	cs    ChainScanner
	store SeedStore
	mu    sync.Mutex
}

// fillUnlockConditions fills in the UnlockConditions for each supplied
// UnspentOutput, transforming them into ValuedInputs. It panics if any
// UnlockConditions cannot be found.
func (w *SeedWallet) fillUnlockConditions(outputs []UnspentOutput) []ValuedInput {
	inputs := make([]ValuedInput, len(outputs))
	for i, o := range outputs {
		uc, ok := w.sm.UnlockConditions(o.UnlockHash)
		if !ok {
			panic("missing unlock conditions for " + o.UnlockHash.String())
		}
		inputs[i] = ValuedInput{
			SiacoinInput: types.SiacoinInput{
				ParentID:         o.ID,
				UnlockConditions: uc,
			},
			Value: o.Value,
		}
	}
	return inputs
}

// ProcessConsensusChange implements modules.ConsensusSetSubscriber.
func (w *SeedWallet) ProcessConsensusChange(cc modules.ConsensusChange) {
	w.mu.Lock()
	w.cs.ProcessConsensusChange(cc)
	w.mu.Unlock()
}

// Addresses returns all addresses generated by the SeedManager.
func (w *SeedWallet) Addresses() []types.UnlockHash {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.sm.Addresses()
}

// AddressInfo returns the metadata associated with the specified address.
func (w *SeedWallet) AddressInfo(addr types.UnlockHash) (SeedAddressInfo, bool) {
	w.mu.Lock()
	defer w.mu.Unlock()
	index, ok1 := w.sm.AddressIndex(addr)
	uc, ok2 := w.sm.UnlockConditions(addr)
	return SeedAddressInfo{
		UnlockConditions: uc,
		KeyIndex:         index,
	}, ok1 && ok2
}

// Balance returns the siacoin balance of the wallet. If the limbo flag is true,
// the balance reflects any transactions currently in Limbo.
func (w *SeedWallet) Balance(limbo bool) types.Currency {
	return SumOutputs(w.UnspentOutputs(limbo))
}

// OwnsAddress reports whether addr was generated from the wallet's seed.
func (w *SeedWallet) OwnsAddress(addr types.UnlockHash) bool {
	w.mu.Lock()
	owned := w.sm.OwnsAddress(addr)
	w.mu.Unlock()
	return owned
}

// NextAddress returns a new address derived from the wallet's Seed and
// updates the wallet's SeedIndex.
func (w *SeedWallet) NextAddress() types.UnlockHash {
	w.mu.Lock()
	defer w.mu.Unlock()
	addr := w.sm.NextAddress()
	w.store.SetSeedIndex(w.sm.CurrentIndex())
	return addr
}

// SeedIndex returns the index that will be used to derive the next
// address.
func (w *SeedWallet) SeedIndex() uint64 {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.sm.CurrentIndex()
}

// SignTransaction signs the specified transaction using keys owned by the
// wallet. If toSign is nil, SignTransaction will automatically add
// TransactionSignatures for each input owned by the SeedManager. If toSign is
// not nil, it a list of indices of TransactionSignatures already present in
// txn; SignTransaction will fill in the Signature field of each.
func (w *SeedWallet) SignTransaction(txn *types.Transaction, toSign []int) error {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.sm.SignTransaction(txn, toSign)
}

// UnspentOutputs returns the spendable outputs tracked by the wallet. If the
// limbo flag is true, the outputs reflect any transactions currently in Limbo.
func (w *SeedWallet) UnspentOutputs(limbo bool) []UnspentOutput {
	w.mu.Lock()
	defer w.mu.Unlock()
	outputs := w.store.UnspentOutputs()
	if limbo {
		outputs = CalculateLimboOutputs(w.sm, w.store.LimboTransactions(), outputs)
	}
	return outputs
}

// ValuedInputs returns the spendable outputs tracked by the wallet along with
// their UnlockConditions, for immediate use as inputs.
func (w *SeedWallet) ValuedInputs() []ValuedInput {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.fillUnlockConditions(w.store.UnspentOutputs())
}

// AddToLimbo stores a transaction in Limbo. If the transaction is already in
// Limbo, its LimboSince timestamp is not updated.
func (w *SeedWallet) AddToLimbo(txn types.Transaction) {
	w.mu.Lock()
	w.store.AddToLimbo(txn)
	w.mu.Unlock()
}

// RemoveFromLimbo removes a transaction from Limbo.
func (w *SeedWallet) RemoveFromLimbo(txid types.TransactionID) {
	w.mu.Lock()
	w.store.RemoveFromLimbo(txid)
	w.mu.Unlock()
}

// LimboTransactions returns the transactions that have been broadcast, but have
// not appeared in the blockchain.
func (w *SeedWallet) LimboTransactions() []LimboTransaction {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.LimboTransactions()
}

// SetMemo sets the memo associated with the specified transaction.
func (w *SeedWallet) SetMemo(txid types.TransactionID, memo []byte) {
	w.mu.Lock()
	defer w.mu.Unlock()
	w.store.SetMemo(txid, memo)
}

// Memo returns the memo associated with the specified transaction.
func (w *SeedWallet) Memo(txid types.TransactionID) []byte {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.Memo(txid)
}

// BlockRewards returns the block rewards tracked by the wallet.
func (w *SeedWallet) BlockRewards(n int) []BlockReward {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.BlockRewards(n)
}

// FileContracts returns the file contracts tracked by the wallet.
func (w *SeedWallet) FileContracts(n int) []FileContract {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.FileContracts(n)
}

// FileContractHistory returns the set of revisions made to the specified
// contract.
func (w *SeedWallet) FileContractHistory(id types.FileContractID) []FileContract {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.FileContractHistory(id)
}

// Transactions returns the IDs of the n most recent transactions in the
// blockchain that are relevant to the SeedWallet, or fewer if less than n such
// transactions exist. If n < 0, all such transactions are returned. The IDs are
// ordered from oldest to newest.
func (w *SeedWallet) Transactions(n int) []types.TransactionID {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.Transactions(n)
}

// TransactionsByAddress returns the IDs of the n most recent transactions in
// the blockchain that are relevant to the specified wallet-owned address, or
// fewer if less than n such transactions exist. If n < 0, all such transactions
// are returned. The IDs are ordered from oldest to newest.
func (w *SeedWallet) TransactionsByAddress(addr types.UnlockHash, n int) []types.TransactionID {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.TransactionsByAddress(addr, n)
}

// Transaction returns the transaction with the specified id. The transaction
// must be relevant to the SeedWallet.
func (w *SeedWallet) Transaction(id types.TransactionID) (types.Transaction, bool) {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.Transaction(id)
}

// ChainHeight returns the number of blocks processed by the wallet.
func (w *SeedWallet) ChainHeight() types.BlockHeight {
	w.mu.Lock()
	defer w.mu.Unlock()
	return w.store.ChainHeight()
}

// ConsensusChangeID returns the ConsensusChangeID most recently processed by
// the wallet.
func (w *SeedWallet) ConsensusChangeID() modules.ConsensusChangeID {
	return w.store.ConsensusChangeID()
}

// NewSeedWallet intializes a SeedWallet using the provided seed and store.
func NewSeedWallet(sm *SeedManager, store SeedStore) *SeedWallet {
	return &SeedWallet{
		sm:    sm,
		store: store,
		cs: ChainScanner{
			Owner: sm,
			Store: store,
		},
	}
}
